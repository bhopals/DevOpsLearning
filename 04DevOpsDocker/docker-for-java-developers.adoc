

Github Repo : https://github.com/arun-gupta/docker-for-java

= Chapter 1

==  Introduction to Docker

	BUILD --> Docker Image     		
	
	SHIP  --> Docker Hub   / Docker Trusted Registry (DTR) / Public or Private Cloud   	
	RUN   --> Docker Container 

WildFly -
	WildFly, formerly known as JBoss AS, or simply JBoss, is an application server authored by JBoss, now developed by Red Hat. WildFly is written in Java and implements the Java Platform


==== DOCKER 
	- Docker is an application delivery technology. 
	- It gives you the ability to build an application using Docker image, 
	- Ship an application using Docker Hub, or registry is another term for shipping, - Run the application as a Docker container, potentially on multiple hosts
	- Even multiple instances of a container just to avoid a single point of failure 


WORA - Write Once, Run Anywhere - JAVA
PORA - Package Once, Deploy Anywhere - Docker 


DOCKER ENGINE linux like cGroups and namespaces that gives Docker a facility to run images in isolation using containers.

== Docker Workflow

Client - Stateles and dumb Docker cli- Send commands to Docker Host via REST API CALL

Docker Host / Docker hub/ Docker Engine - Which has Docker Daemon that listens the REST API call and RESPOND. Pull the requested image from Registry if not locally available and then run that image (container).


Registry - Public / Private Directory / DTR  


== Getting Started with Docker

. Create Docker Machine: `docker-machine create -d virtualbox mymachine`
.. Talk about `boot2docker.iso`
. Show `env | grep DOCKER`
. Setup machine: `eval $(docker-machine env mymachine)`
. Show `env | grep DOCKER`

==================================================================================================================


 === Docker Image 

  COPY - Copy files from Source to target directory  

  ADD - Same as COPY command + it can extract and copy ZIP/TAR files as well. Moreover, have support for exexution of CURL command.

$ docker container run -p 8080:8080 <image-name>  


= Chapter 2

== 2.1 Docker CLI

Show Docker CLI commands

== 2.2 Run your first Docker container

```
docker container run -it jboss/wildfly

The docker run subcommand takes an image as an input and launches it as a container. You have to pass the -t and -i flags to the docker run subcommand in order to make the container interactive. The -i flag is the key driver, which makes the container interactive by grabbing the standard input (STDIN) of the container. The -t flag allocates a pseudo-TTY or a pseudo terminal (terminal emulator) and then assigns that to the container.

http://dinus.ac.id/private_lib/fahri/LEARNING_DOCKER.pdf

The benefit if passing "it" command, the container will not be killed if I press CTRL+C, which otherwise be killed if I didn't use "it" flag. If you want to kill
the container started in INTERACTIVE MODE, then you need to go by a different path. (docker container stop <id/name> )


docker container run -d jboss/wildfly

	Here "d" flag denotes, starting a container in DETACHED Mode. 


When you run an image with only -d option, the container will exit immediately after the command executed. If you run with -itd option, the container will be detached but running in background, and you can attach back when you need. 

In case if "it" - Once container is up, the command will not exit automatically
(although the container will keep running in background as its in interactive mode)

In case if "itd" - Once container is up, the command will exit automatically
(although the container will keep running in background as its in interactive mode)



-i (interactive) is about whether to keep stdin open (some programs, like bash, use stdin and other programs don't). -d (detached) is about whether the docker run command waits for the process being run to exit. Thus, they are orthogornal and not inherently contradictory. A program like bash exits when stdin in closed, so without -i, it exits immediately.

-t allocates a pseudo-tty. You can see the difference from running bash with -it vs with just -i. For example, without -t, you don't get any prompt and ls shows results in one column. This difference is like the difference between running ls and running ls | cat, where cat does not have a pseudo-tty.

When you docker run bash in a container, -it and -itd behave differently as follows:

With -it, docker run gives you the bash prompt immediately.
With -itd, docker run exits immediately, but you can docker attach after that and get the bash prompt just as if you had just done docker run -it.




docker container ls
docker container stop {name}
docker container rm {name}

docker container run -d web jboss/wildfly
	- Docker will give some custome name of this container.

docker container run -d --name web jboss/wildfly
	- Here since we passed the "name", Docker will keep this the name of the container.


docker container ls
docker container rm -f web
docker container run -it --name web jboss/wildfly bash
```


To Use any container, we need to expose ports. And attach volumes to it so that it can deploy .war files to it



== 2.3 Run Docker container (ports & volumes)

=== Expose ports

```
docker container run -d --name web -P jboss/wildfly
docker container run ls
docker container logs web
```

Access WildFly home page in browser on the exposed port

=== Expose ports

```
docker container stop web
docker container rm web
docker container run -d --name web -p 8080:8080 jboss/wildfly
docker container logs web
```

Access WildFly home page in browser on 8080


=== Volume mapping

```
docker container rm -f web
docker container run -d --name web -p 8080:8080 -v `pwd`/webapp.war:/opt/jboss/wildfly/standalone/deployments/webapp.war jboss/wildfly
docker container logs web -f
curl http://localhost:8080/webapp/resources/persons
```

`webapp.war` is used from https://github.com/javaee-samples/javaee7-simple-sample/releases/download/v1.10/javaee7-simple-sample-1.10.war.

=== 2.4 Create first Docker image

. Dockerfile syntax
. Create a new directory
. Explain build context

```
FROM ubuntu

CMD echo "Hello world"
```

. Build image: `docker image build -t helloworld .`


	"docker image build", because we need to build the image, and we want to give the image a tag name, so we're going to call it hello world. And, we're going to say "dot". Now, this is where creating a brand new directory is important. Because, essentially what's happening now is the docker CLI is giving a command to the docker host, build an image, and by saying dot, I am giving it a context. And I'm giving the current directory as the context. An entire context is sent from the client to the host. Now, if you do that in a directory which is populated with lot of other files and directories, entire content is then sent over to the host, which is not really necessary. It is very important that you actually create a new directory, and put Dockerfile over there. Now we understand sometimes it may not be possible to do that, in which case, just like in a get directory, or in a get project, you have dot get ignore, similarly you can have a "dot docker ignore". If you really have to do this in a directory which has a lot of other files and directories, then you can have dot docker ignore file, which follows very similar format as dot get ignore. From our persepective, it's just docker image build dash t hello world dot, and it's an empty directory, so we're going to build this image. 

. Explain `.dockerignore`
. List image: `docker image ls`
. History of image: `docker image history helloworld`
. Run container: `docker container run helloworld`
. Explain `--compress`
. Explain `--squash`


 https://docs.docker.com/engine/reference/builder/



=== 2.5 Create first Java Docker image

```
FROM openjdk

CMD java -version
```

. Build image: `docker image build -t hellojava .`
. List image and show the size: `docker image ls`
. Run container: `docker container run hellojava`

```
FROM openjdk:jdk-alpine

CMD java -version
```

. Build image: `docker image build -t hellojava:2 .`
. Talk about image tagging
. List image and show/compare the size: `docker image ls`
. Run container: `docker container run hellojava:2`

=== 2.6 Copy files in the Docker image

. Explain `COPY` vs `ADD`

```
FROM jboss/wildfly

COPY webapp.war /opt/jboss/wildfly/standalone/deployments/webapp.war
```

. Build image: `docker image build -t helloweb .`
. Run container: `docker container run -p 8080:8080 -d helloweb`
. Access application: `curl http://localhost:8080/webapp/resources/persons`

=== 2.7 Run JAR files from the Docker image

```
FROM openjdk:jdk-alpine

COPY myapp/target/myapp-1.0-SNAPSHOT.jar /deployments/

CMD java -jar /deployments/myapp-1.0-SNAPSHOT.jar
```

. Create JAR file: `mvn -f myapp/pom.xml clean package`
. Build image: `docker image build -t hellojava:3 .`
. Run container: `docker container run hellojava:3`
. Change Java application (change "Hello" to "Howdy")
. Create new JAR file using `mvn -f myapp/pom.xml clean package`
. Build new Docker image: `docker image build -t hellojava:4 .`
. Run new Docker container: `docker container run hellojava:4`
. Show updated changes

=== 2.8 Other Dockerfile instructions

Slides only

=== 2.9 Docker and Maven

. Check out https://github.com/arun-gupta/docker-java-sample
. Run using CLI: `mvn clean package exec:java`
. Show `pom.xml` and explain DMP (Add Docker Maven Profile in pom.xml) - Fabrix maven plugin
. Build image: `mvn package -Pdocker`
. Show image: `docker image ls`
. Run container: `mvn install -Pdocker`

=== 2.10 Docker and Gradle

. Check out https://github.com/arun-gupta/docker-java-sample
. Run using CLI: `./gradlew build run`
. Show `build.gradle` and explain Docker Gradle Plugin
. Build image: `./gradlew dockerBuildImage`
. Show image: `docker image ls`
. Run container: `./gradlew startContainer`


=== 2.11 Tag and Share Docker Image

. Show tags at https://hub.docker.com/_/openjdk/

$ docker image ls (It will show all the images with detailed information)
$ docker image ls -aq

-aq : All Quiet and in this case it will only return list of Image ID'sample

$ docker image rm -f $(docker image ls -aq)

So we have the option to pass subcommands 


docker image build . 

In this case REPOSITORY and TAG will be <none> because we have not specified any TAG here.

docker image build -t helloworld:version-2 .

Now Repository name would be "helloworld" and tag would be "version-2"
Here "." is the build context

To START a private and local registry 

$ docker run -d -p 5000:5000 --restart always --name registry registry:2.6.0

Now to send any build image to local registry we need to tag it

$ docker image tag helloworld:latest localhost:5000/<user-id>/<image-naem>:<tag-name>
Once tagged, we need to push the image to local registry

$ docker image push localhost:5000/<user-id>/<image-name>:<tag-name>



=============================================================================


= Chapter 3 - Multiple Container Application 

== 3.1 Introduction to Docker Compose

	- Typical applications have multiple components 
	- You can easily run multicontainer applications with Docker Compose 
	- Define and run multicontainer applications 
	- Configuration defined in one or more files 
		* default file name would be 
			docker-compose.yml (default) (but it can be overriden)
			docker-compose.override.yml (default) 

		When we build both files configuration will got merged. docker-compose.override.yml will take precendence over mai file 
		so it will have the entries that are supposed to be overridden.

		We can have multiple configuration files and in that case an additional falg "-f" should be passed 
		to specify paths of all files at the time of build.

	- Single commad to manage all services 
	- Great for dev, staging, and CI 
	

Slides

. Installed as part of Docker Toolbox or github.com/docker/compose/releases
. `docker-compose -v`
. `docker-compose --help`. Explain `up`, `ps`, `down`, `scale`, `restart`, `port`

== 3.2 Docker Compose file

. Create a directory `helloweb`
. Create Compose file in `helloweb` directory: `vi docker-compose.yml`

```
version: '3'
services:
  web:
    image: jboss/wildfly
    volumes:
      - ~/deployments:/opt/jboss/wildfly/standalone/deployments
    ports:
      - 8080:8080
```

. Talk about how `deployments` directory is automatically created
. Explain `web`, `image`, `volumes`, `ports`
. Compare with Docker CLI

Run the commands:


Once files is created, run "docker-compose up -d" command to start the services  

Run "docker-compose ps" to see the running services 

Run "docker-compose logs -f" to check the logs of deployed service 


```

docker-compose up -d
docker-compose logs -f

cp docker-for-java-master/chapter2/webapp.war ~/deployments
curl http://localhost:8080/webapp/resources/persons
docker-compose down
```

=== 3.3 Multi-container application

. Create a directory `travel`

```
version: '3'
services:
  web:
    image: arungupta/couchbase-javaee:travel
    environment:
      - COUCHBASE_URI=db
    ports:
      - 8080:8080
      - 9990:9990
    depends_on:
      - db
  db:
    image: arungupta/couchbase:travel
    ports:
      - 8091:8091
      - 8092:8092
      - 8093:8093
      - 11210:11210
```




. Two images `web` and `db`
. Explain `depdends_on` - container and app starting sequence
. `COUCHBASE_URI` - show code
. Start application: `docker-compose up -d`
. Show logs: `docker-compose logs -f`
. Access application: `curl http://localhost:8080/airlines/resources/airline`
. Shutdown application: `docker-compose down`

== 3.4 Docker Compose options

=== Project name

Multiple projects using -p 
 - Create Multiple isolated environments on a host 


By default, service names is <project-name>_<service-name>_<service-number>
Start using `docker-compose -p myapp up -d`
`docker-compose ps` shows no services
`docker-compose -p myapp ps` shows services

So "-p" will create a context for the service to run in more isolation. 
If we create any contect the we need to interact to that service in isolation only 

Example :

$ docker-compose -p myapp up -d 
  - Start the service in <myapp> context 

$ docker-compose -p ps 
  - Will not show anything 

$ docker-compose -p myapp ps 
	- This will list out the process running 

Also the same way to stop such services :
$ docker-compose -p myapp down 

This "-p" feature is especially useful when we want to spin up the services for TEST/STAGE/UAT environment pointing to the same git repo.
In this way, the context would help in isolation and smpooth running of all the environment, and can individually shut down once testing is done.



=== Default Override

	File: docker-compose.override.yml 

	- It replaces or extend values 
	- Single-value options like "image" replace the old value.
	- Multivalue options like ports are concatenated; newer values and high precedence 

	
The proper use case is that we can create docker-compose.override files for each environment and let it override depends on environment (sit,test,stage) to expose the port at the time of deloyment.



Copy the following in `docker-compose.override.yml`:

```
version: "3"
services:
  web:
   ports:
     - 80:8080
```

. Run application: `docker-compose up -d`.
. App now accessible at curl http://localhost/webapp/resources/persons
. Shutdown using `docker-compose down`

== 3.5 Docker Compose options

- Multiple files using -f 
	Replace or extend the parent value 


	Run: 
		$ docker-compose \
			-f docker-compose.yml \
			-f docker-compose.db.yml
			up -d 

	Services: 
		$ docker-compose \
			-f docker-compose.yml \
			-f docker-compose.db.yml
			ps  


	Shutdown: 
		$ docker-compose \
			-f docker-compose.yml \
			-f docker-compose.db.yml
			down  
			

- Extending services 
	Use extends 

	Filename: configuration.yml 
	```
	version: '3'
	services:
		config:
			environment:
				AWS_ACCESS_KEY: XXXXX
				AWS_SECRET_KEY: XXXXX 

	```

	Filename: docker-compose.yml 
	```
		version: '3'
		services:
		web:
			extends:
				file:configuration.yml 
				service: config 
			image: jboss/wildfly
			volumes:
			- ~/deployments:/opt/jboss/wildfly/standalone/deployments
			ports:
			- 8080:8080
	```


So when you run the command, environment details from config file got set.

To see the details what all the files are used in forming the final version of docker-compose.yml then use "verbose" flag while running the command to up the service.

docker-compose --verbose up -d 
 
. Docker image name format: `<registry>/repo_name:tag`
.. Default value of `<registry>` is `docker.io`



==== Docker Compose: Common Use Cases 

	Dev setup - 
		docker-compose up 
	
	Local/remote host - 
		DOCKER_HOST, DOCKER_TLS_VERIFY, DOCKER_CERT_PATH
	
	Single/multiple hosts - 
		Integrated with Swarm
	
	Multiple isolated environments - 
		docker-compose up -p <project-name>
	
	Automated test setup - 
		docker-compose up 
		mvn test 
		docker-compose down 

	Dev/prod impedance mismatch 
		docker-compose up -f docker-compose.yml -f docker-production.yml 
		 

==== Dockerfile

Use Dockerfile:

```
FROM ubuntu:latest

CMD echo "This is v1"
```

==== Remove all images and containers

. `docker image rm -f $(docker image ls -qa)`
. `docker container rm -f $(docker container ls -aq)`

==== Image with no name or tag

. Build image: `docker image build .`
. List image: Use `docker image ls` to show the list of images, particular `<none>:<none>` for this image
. Run container: `docker container run <image-id>`, have no name

==== Image with no name and default `latest` tag

. Build image: `docker image build -t helloworld .`
. List image: `docker image ls`, show default `<none>:<none>` is gone, `latest` tag is created
. Run container: `docker container run helloworld` and `docker container run helloworld:latest`

==== Image with name and explicit tag

. Remove all containers: `docker container rm -f $(docker container ls -aq)`
. Remove image with `latest` tag: `docker image rm helloworld:latest`
. Build image: `docker image build -t helloworld:1 .`
. List image: `docker image ls`, show no `latest` tag
. Run container: `docker container run helloworld:1`
. Run `latest` container: `docker container run helloworld` and `docker container run helloworld:latest`

==== Tag versioned image with `latest` tag

. Tag image: `docker image tag helloworld:1 helloworld:latest`
. List images: `docker image ls`, show both tags are available
. Run `latest` container (now works): `docker container run helloworld` and `docker container run helloworld:latest`

==== Is `latest` really latest?

Use Dockerfile:

```
FROM ubuntu:latest

CMD echo "This is v2"
```

. Build image: `docker image build -t helloworld:2 .`
. Run container: `docker container run helloworld` shows v1
. Tag v2 to `latest`: `docker image tag helloworld:2 helloworld:latest`
. Run container: `docker container run helloworld` shows v2 now

==== Push image to Docker Hub

. Push the image without namespace and show the error: `docker image push helloworld:latest`
. Tag image: `docker image tag helloworld:2 arungupta/helloworld:latest`
. Login to Docker: `docker login`
. Push to Docker Hub: `docker image push arungupta/helloworld:latest`
. Push to local registry
.. Run registry: `docker container run -d -p 5000:5000 --restart always --name registry registry:2.6.0`
.. Tag image for local registry: `docker image tag helloworld:latest localhost:5000/arungupta/helloworld:latest`
.. Use `docker image ls` to show the list of images
.. Push to local registry: `docker image push localhost:5000/arungupta/helloworld:latest`







= Chapter 4

== 4.1 Introduction to Swarm mode


=== Docker Swarm 

	===== Swarm Mode
	 - Declarative State Model 
	 - Self-organizing and self-healing 
	 - Service Discovery, load balancing, and scaling 
	 - Rolling updates 


	===== Swarm Mode Protocol 
		This protocol state that Swarm must have odd number of manager.
		why is it recommended to have an odd number of Managers?
		 First of all, Docker Swarm uses a 
		 Raft consensus group.
		  The reason why Docker Swarm mode is using a consensus algorithm is to make sure that all the Manager Nodes that are in charge of managing and scheduling tasks in the cluster are storing the same consistent state. 


		  This isn't about how many Manager nodes to implement, it's a trade off between performance and fall tolerance. Adding Manager nodes to a swarm makes a swarm more fall tolerant, however, additional manager nodes reduce write performance because more nodes must acknowledge proposals to update the swarm state.
		   This means more network-run traffic.


	- Strong consistent
	- Replicated (Raft Based)
	- Extremely Fast (In-memory read)


	Docker Swarm Security - It is secure by default 

	MANAGER NODE --> TLS and Certificate Authority 
	WORKER --> TLS 

	Supports Automatic Encryption and manual authentication.
	Automatic Certificate update
	Cryptographic Node identity
	
	

. Show options: `docker swarm --help`
. Single node swarm: `docker swarm init`
. Show information: `docker info`
. Leave swarm: `docker swarm leave` and `docker swarm leave -f`

== 4.2 Create multi-node Swarm mode cluster using Docker Machine

Slides

Complete script to create the cluster: `swarm-cluster.sh`

. `docker-machine -v`
. Pre-create 6 Docker Machines using `swarm-machines.sh`
. Show list of machines: `docker-machine ls`
. Initialize swarm mode on `manager`:
+
```
docker-machine ssh manager1 \
        "docker swarm init \
        --listen-addr $(docker-machine ip manager1) \
        --advertise-addr $(docker-machine ip manager1)"
```
+
. Show list of nodes: `docker-machine ssh manager1 "docker node ls"`
. Get manager token: `docker-machine ssh manager1 "docker swarm join-token manager -q"`
. Get worker token: `docker-machine ssh manager1 "docker swarm join-token worker -q"`
. Manager 2 joins cluster:
+
```
docker-machine ssh manager2 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token manager -q"` \
        --listen-addr $(docker-machine ip manager2) \
        --advertise-addr $(docker-machine ip manager2) \
        $(docker-machine ip manager1)"
```
+
. Show list of nodes: `docker-machine ssh manager1 "docker node ls"`
. Manager 3 joins cluster:
+
```
docker-machine ssh manager3 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token manager -q"` \
        --listen-addr $(docker-machine ip manager3) \
        --advertise-addr $(docker-machine ip manager3) \
        $(docker-machine ip manager1)"
```
+
. Show list of nodes: `docker-machine ssh manager1 "docker node ls"`
. Worker 1 join cluster:
+
```
docker-machine ssh worker1 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker1) \
        --advertise-addr $(docker-machine ip worker1) \
        $(docker-machine ip manager1)"
```
+
. Show list of nodes: `docker-machine ssh manager1 "docker node ls"`
. Worker 2 join cluster:
+
```
docker-machine ssh worker2 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker2) \
        --advertise-addr $(docker-machine ip worker2) \
        $(docker-machine ip manager1)"
```
+
. Worker 3 join cluster:
+
```
docker-machine ssh worker3 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker3) \
        --advertise-addr $(docker-machine ip worker3) \
        $(docker-machine ip manager1)"
```
+
. Show list of nodes: `docker-machine ssh manager1 "docker node ls"`
. Show cluster information: `docker-machine ssh manager1 "docker info"`

== 4.3 Deploying services to Swarm mode

Slides

=== Create service

. SSH to `manager1`: `docker-machine ssh manager1`
. Create a replicated service: `docker service create --name web --replicas 3 -p 8080:8080 jboss/wildfly`
. List service and replicas: `docker service ls`
. Inspect service: `docker service inspect web`
. List containers: `docker service ps web`

== 4.4 Container or Node failure

Slides

=== Container failure

. In `manager1`, see the nodes where containers are running: `docker service ps web`
. SSH to a node where the container is running. Show the list of containers: `docker container ls`
. Exit out of `manager1`
. Show the number of replicas: `docker-machine ssh manager1 "docker service ls"`
. Kill a container: `docker-machine ssh <node> "docker container rm -f <cid>"`
.. `<node>` is where the container is running
.. `<cid>` is the id of the container
. Show the replicas in service: `docker-machine ssh manager1 "docker service ls"`
.. Show that only 2 replicas are running and reconciliation happens by swarm manger

=== Node failure

. Show the list of nodes: `docker-machine ls`
. Show the node where containers are running: `docker-machine ssh manager1 "docker service ps web"`
. Show number of replicas for the service: `docker-machine ssh manager1 "docker service ls"`
. Stop a node where the container is running: `docker-machine stop <node>`
. Show the list of nodes: `docker-machine ls`
. Show the services: `docker-machine ssh manager1 "docker service ls"`
. Show how desired vs actual is reconciled: `docker service ls`
. Show how container is started on a different node: `docker service ps web`

== 4.5 Scaling and rolling update of service

Slides

=== Scale service

. List service and replicas: `docker ssh manager1 "docker service ls"`
. Show node where containers are running: `docker ssh manager1 "docker service ps web"`
. Use filters to restrict output: `docker-machine ssh manager1 "docker service ps -f \"desired-state=running\" web"`
. SSH to `manager`: `docker-machine ssh manager1`
. Check the list of running services again: `docker service ps -f "desired-state=running" web`
. Scale service: `docker service scale web=6`
. Shutdown service: `docker service rm web`
. Show the list of services: `docker service ls`

=== Rolling update of service

. Create 6 replicas of a service: `docker service create --name webapp --replicas 6 -p 8080:8080 arungupta/wildfly-app:1`
. Check service: `docker service ls`
. Check tasks in the service: `docker service ps webapp`. Show the version of image in each app.
. Access the application http://192.168.99.100:8080/app/index.jsp and show green background
. Rolling update service: `docker service update webapp --image arungupta/wildfly-app:2 --update-parallelism 2 --update-delay 10s`
. Check status every 5 secs: `docker service ps webapp`
. Access the application http://192.168.99.100:8080/app/index.jsp and show red background

== 4.6 Multi-container application on multi-host cluster

. Show the list of services: `docker service ls`
. Remove service `docker service rm webapp`
. Login to `manager1`: `docker-machine ssh manager1`
. Create a new file `docker-compose.yml` and use the following content:
+
```
version: '3'
services:
  web:
    image: arungupta/couchbase-javaee:travel
    environment:
      - COUCHBASE_URI=db
    ports:
      - 8080:8080
      - 9990:9990
    depends_on:
      - db
  db:
    image: arungupta/couchbase:travel
    ports:
      - 8091:8091
      - 8092:8092
      - 8093:8093
      - 11210:11210
```
+
. Deploy: `docker stack deploy --compose-file=docker-compose.yml webapp`
. `docker stack ls`
. `docker service ls`
. `docker service ps webapp_web` - show the node where the container is running
. `docker service ps webapp_db` - show the node where the container is running
. See the logs of `web` service
.. Log in to the node where container is running: `docker-machine ssh <node-name>`
.. See the list of containers: `docker container ls`
.. View logs: `docker container logs <cid>`
.. Alternatively (only on experimental) `docker service logs webapp_web`
. Access the application `curl -v http://$(docker-machine ip <node>):8080/airlines/resources/airline`
. Remove stack: `docker stack rm webapp`

== 4.7 Node maintenance, label/constraints, global service

Slides only

== 4.8 Create multi-node Swarm mode cluster on AWS/Azure

Slides

. Go to docker.com/getdocker
. Launch the template and explain the creation and parameters
. SSH into instance: `ssh -i ~/.ssh/arun-docker.pem docker@<master-ip>`
. Show more details: `docker info`
. Show node listing: `docker node ls`
. Setup SSH tunnel: `ssh -i ~/.ssh/arun-docker.pem -NL localhost:2374:/var/run/docker.sock docker@<master-ip>`
. Show cluster information: `docker -H localhost:2374 info`



//File name : swarm-cluster.sh 
docker-machine ssh manager1 \
        "docker swarm init \
        --listen-addr $(docker-machine ip manager1) \
        --advertise-addr $(docker-machine ip manager1)"
docker-machine ssh manager2 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token manager -q"` \
        --listen-addr $(docker-machine ip manager2) \
        --advertise-addr $(docker-machine ip manager2) \
        $(docker-machine ip manager1)"
docker-machine ssh manager3 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token manager -q"` \
        --listen-addr $(docker-machine ip manager3) \
        --advertise-addr $(docker-machine ip manager3) \
        $(docker-machine ip manager1)"
docker-machine ssh worker1 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker1) \
        --advertise-addr $(docker-machine ip worker1) \
        $(docker-machine ip manager1)"
docker-machine ssh worker2 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker2) \
        --advertise-addr $(docker-machine ip worker2) \
        $(docker-machine ip manager1)"
docker-machine ssh worker3 \
        "docker swarm join \
        --token `docker-machine ssh manager1 "docker swarm join-token worker -q"` \
        --listen-addr $(docker-machine ip worker3) \
        --advertise-addr $(docker-machine ip worker3) \
        $(docker-machine ip manager1)"
docker-machine ssh manager1 "docker node ls"


//FileName: swarm-machines.sh
#!/bin/bash

# Swarm mode using Docker Machine

managers=3
workers=3

# create manager machines
echo "======> Creating $managers manager machines ...";
for node in $(seq 1 $managers);
do
	echo "======> Creating manager$node machine ...";
	docker-machine create -d virtualbox manager$node;
done

# create worker machines
echo "======> Creating $workers worker machines ...";
for node in $(seq 1 $workers);
do
	echo "======> Creating worker$node machine ...";
	docker-machine create -d virtualbox worker$node;
done

# list all machines
docker-machine ls



===== Swarm Mode: Routing Mesh 
 - Load balancers are host-aware, not container-aware
 - Swarm mode introduces the container-aware routing 
 - It reroutes traffic from any host to a container 
	- Reserves a swarm-wide ingress port 
	- Uses DNS-based service discovery 
	
